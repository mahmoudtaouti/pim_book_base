// coverage:ignore-file
// GENERATED CODE - DO NOT MODIFY BY HAND
// ignore_for_file: type=lint
// ignore_for_file: unused_element, deprecated_member_use, deprecated_member_use_from_same_package, use_function_type_syntax_for_parameters, unnecessary_const, avoid_init_to_null, invalid_override_different_default_values_named, prefer_expression_function_bodies, annotate_overrides, invalid_annotation_target, unnecessary_question_mark

part of 'failures.dart';

// **************************************************************************
// FreezedGenerator
// **************************************************************************

T _$identity<T>(T value) => value;

final _privateConstructorUsedError = UnsupportedError(
    'It seems like you constructed your class using `MyClass._()`. This constructor is only meant to be used by freezed and you are not supposed to need it nor use it.\nPlease check the documentation here for more information: https://github.com/rrousselGit/freezed#custom-getters-and-methods');

/// @nodoc
mixin _$DatabaseFailure<T> {
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() insufficientStorageSpace,
    required TResult Function() permissionDenied,
    required TResult Function() notFound,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? insufficientStorageSpace,
    TResult? Function()? permissionDenied,
    TResult? Function()? notFound,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? insufficientStorageSpace,
    TResult Function()? permissionDenied,
    TResult Function()? notFound,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(InsufficientStorageSpace<T> value)
        insufficientStorageSpace,
    required TResult Function(PermissionDenied<T> value) permissionDenied,
    required TResult Function(NotFound<T> value) notFound,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(InsufficientStorageSpace<T> value)?
        insufficientStorageSpace,
    TResult? Function(PermissionDenied<T> value)? permissionDenied,
    TResult? Function(NotFound<T> value)? notFound,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(InsufficientStorageSpace<T> value)?
        insufficientStorageSpace,
    TResult Function(PermissionDenied<T> value)? permissionDenied,
    TResult Function(NotFound<T> value)? notFound,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $DatabaseFailureCopyWith<T, $Res> {
  factory $DatabaseFailureCopyWith(
          DatabaseFailure<T> value, $Res Function(DatabaseFailure<T>) then) =
      _$DatabaseFailureCopyWithImpl<T, $Res, DatabaseFailure<T>>;
}

/// @nodoc
class _$DatabaseFailureCopyWithImpl<T, $Res, $Val extends DatabaseFailure<T>>
    implements $DatabaseFailureCopyWith<T, $Res> {
  _$DatabaseFailureCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;
}

/// @nodoc
abstract class _$$InsufficientStorageSpaceCopyWith<T, $Res> {
  factory _$$InsufficientStorageSpaceCopyWith(
          _$InsufficientStorageSpace<T> value,
          $Res Function(_$InsufficientStorageSpace<T>) then) =
      __$$InsufficientStorageSpaceCopyWithImpl<T, $Res>;
}

/// @nodoc
class __$$InsufficientStorageSpaceCopyWithImpl<T, $Res>
    extends _$DatabaseFailureCopyWithImpl<T, $Res,
        _$InsufficientStorageSpace<T>>
    implements _$$InsufficientStorageSpaceCopyWith<T, $Res> {
  __$$InsufficientStorageSpaceCopyWithImpl(_$InsufficientStorageSpace<T> _value,
      $Res Function(_$InsufficientStorageSpace<T>) _then)
      : super(_value, _then);
}

/// @nodoc

class _$InsufficientStorageSpace<T> implements InsufficientStorageSpace<T> {
  const _$InsufficientStorageSpace();

  @override
  String toString() {
    return 'DatabaseFailure<$T>.insufficientStorageSpace()';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$InsufficientStorageSpace<T>);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() insufficientStorageSpace,
    required TResult Function() permissionDenied,
    required TResult Function() notFound,
  }) {
    return insufficientStorageSpace();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? insufficientStorageSpace,
    TResult? Function()? permissionDenied,
    TResult? Function()? notFound,
  }) {
    return insufficientStorageSpace?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? insufficientStorageSpace,
    TResult Function()? permissionDenied,
    TResult Function()? notFound,
    required TResult orElse(),
  }) {
    if (insufficientStorageSpace != null) {
      return insufficientStorageSpace();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(InsufficientStorageSpace<T> value)
        insufficientStorageSpace,
    required TResult Function(PermissionDenied<T> value) permissionDenied,
    required TResult Function(NotFound<T> value) notFound,
  }) {
    return insufficientStorageSpace(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(InsufficientStorageSpace<T> value)?
        insufficientStorageSpace,
    TResult? Function(PermissionDenied<T> value)? permissionDenied,
    TResult? Function(NotFound<T> value)? notFound,
  }) {
    return insufficientStorageSpace?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(InsufficientStorageSpace<T> value)?
        insufficientStorageSpace,
    TResult Function(PermissionDenied<T> value)? permissionDenied,
    TResult Function(NotFound<T> value)? notFound,
    required TResult orElse(),
  }) {
    if (insufficientStorageSpace != null) {
      return insufficientStorageSpace(this);
    }
    return orElse();
  }
}

abstract class InsufficientStorageSpace<T> implements DatabaseFailure<T> {
  const factory InsufficientStorageSpace() = _$InsufficientStorageSpace<T>;
}

/// @nodoc
abstract class _$$PermissionDeniedCopyWith<T, $Res> {
  factory _$$PermissionDeniedCopyWith(_$PermissionDenied<T> value,
          $Res Function(_$PermissionDenied<T>) then) =
      __$$PermissionDeniedCopyWithImpl<T, $Res>;
}

/// @nodoc
class __$$PermissionDeniedCopyWithImpl<T, $Res>
    extends _$DatabaseFailureCopyWithImpl<T, $Res, _$PermissionDenied<T>>
    implements _$$PermissionDeniedCopyWith<T, $Res> {
  __$$PermissionDeniedCopyWithImpl(
      _$PermissionDenied<T> _value, $Res Function(_$PermissionDenied<T>) _then)
      : super(_value, _then);
}

/// @nodoc

class _$PermissionDenied<T> implements PermissionDenied<T> {
  const _$PermissionDenied();

  @override
  String toString() {
    return 'DatabaseFailure<$T>.permissionDenied()';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is _$PermissionDenied<T>);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() insufficientStorageSpace,
    required TResult Function() permissionDenied,
    required TResult Function() notFound,
  }) {
    return permissionDenied();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? insufficientStorageSpace,
    TResult? Function()? permissionDenied,
    TResult? Function()? notFound,
  }) {
    return permissionDenied?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? insufficientStorageSpace,
    TResult Function()? permissionDenied,
    TResult Function()? notFound,
    required TResult orElse(),
  }) {
    if (permissionDenied != null) {
      return permissionDenied();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(InsufficientStorageSpace<T> value)
        insufficientStorageSpace,
    required TResult Function(PermissionDenied<T> value) permissionDenied,
    required TResult Function(NotFound<T> value) notFound,
  }) {
    return permissionDenied(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(InsufficientStorageSpace<T> value)?
        insufficientStorageSpace,
    TResult? Function(PermissionDenied<T> value)? permissionDenied,
    TResult? Function(NotFound<T> value)? notFound,
  }) {
    return permissionDenied?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(InsufficientStorageSpace<T> value)?
        insufficientStorageSpace,
    TResult Function(PermissionDenied<T> value)? permissionDenied,
    TResult Function(NotFound<T> value)? notFound,
    required TResult orElse(),
  }) {
    if (permissionDenied != null) {
      return permissionDenied(this);
    }
    return orElse();
  }
}

abstract class PermissionDenied<T> implements DatabaseFailure<T> {
  const factory PermissionDenied() = _$PermissionDenied<T>;
}

/// @nodoc
abstract class _$$NotFoundCopyWith<T, $Res> {
  factory _$$NotFoundCopyWith(
          _$NotFound<T> value, $Res Function(_$NotFound<T>) then) =
      __$$NotFoundCopyWithImpl<T, $Res>;
}

/// @nodoc
class __$$NotFoundCopyWithImpl<T, $Res>
    extends _$DatabaseFailureCopyWithImpl<T, $Res, _$NotFound<T>>
    implements _$$NotFoundCopyWith<T, $Res> {
  __$$NotFoundCopyWithImpl(
      _$NotFound<T> _value, $Res Function(_$NotFound<T>) _then)
      : super(_value, _then);
}

/// @nodoc

class _$NotFound<T> implements NotFound<T> {
  const _$NotFound();

  @override
  String toString() {
    return 'DatabaseFailure<$T>.notFound()';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is _$NotFound<T>);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() insufficientStorageSpace,
    required TResult Function() permissionDenied,
    required TResult Function() notFound,
  }) {
    return notFound();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? insufficientStorageSpace,
    TResult? Function()? permissionDenied,
    TResult? Function()? notFound,
  }) {
    return notFound?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? insufficientStorageSpace,
    TResult Function()? permissionDenied,
    TResult Function()? notFound,
    required TResult orElse(),
  }) {
    if (notFound != null) {
      return notFound();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(InsufficientStorageSpace<T> value)
        insufficientStorageSpace,
    required TResult Function(PermissionDenied<T> value) permissionDenied,
    required TResult Function(NotFound<T> value) notFound,
  }) {
    return notFound(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(InsufficientStorageSpace<T> value)?
        insufficientStorageSpace,
    TResult? Function(PermissionDenied<T> value)? permissionDenied,
    TResult? Function(NotFound<T> value)? notFound,
  }) {
    return notFound?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(InsufficientStorageSpace<T> value)?
        insufficientStorageSpace,
    TResult Function(PermissionDenied<T> value)? permissionDenied,
    TResult Function(NotFound<T> value)? notFound,
    required TResult orElse(),
  }) {
    if (notFound != null) {
      return notFound(this);
    }
    return orElse();
  }
}

abstract class NotFound<T> implements DatabaseFailure<T> {
  const factory NotFound() = _$NotFound<T>;
}

/// @nodoc
mixin _$ValueFailure<T> {
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() notValidToSaveInDatabase,
    required TResult Function() emptyValue,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? notValidToSaveInDatabase,
    TResult? Function()? emptyValue,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? notValidToSaveInDatabase,
    TResult Function()? emptyValue,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(NotValidToSaveInDatabase<T> value)
        notValidToSaveInDatabase,
    required TResult Function(EmptyValue<T> value) emptyValue,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(NotValidToSaveInDatabase<T> value)?
        notValidToSaveInDatabase,
    TResult? Function(EmptyValue<T> value)? emptyValue,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(NotValidToSaveInDatabase<T> value)?
        notValidToSaveInDatabase,
    TResult Function(EmptyValue<T> value)? emptyValue,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $ValueFailureCopyWith<T, $Res> {
  factory $ValueFailureCopyWith(
          ValueFailure<T> value, $Res Function(ValueFailure<T>) then) =
      _$ValueFailureCopyWithImpl<T, $Res, ValueFailure<T>>;
}

/// @nodoc
class _$ValueFailureCopyWithImpl<T, $Res, $Val extends ValueFailure<T>>
    implements $ValueFailureCopyWith<T, $Res> {
  _$ValueFailureCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;
}

/// @nodoc
abstract class _$$NotValidToSaveInDatabaseCopyWith<T, $Res> {
  factory _$$NotValidToSaveInDatabaseCopyWith(
          _$NotValidToSaveInDatabase<T> value,
          $Res Function(_$NotValidToSaveInDatabase<T>) then) =
      __$$NotValidToSaveInDatabaseCopyWithImpl<T, $Res>;
}

/// @nodoc
class __$$NotValidToSaveInDatabaseCopyWithImpl<T, $Res>
    extends _$ValueFailureCopyWithImpl<T, $Res, _$NotValidToSaveInDatabase<T>>
    implements _$$NotValidToSaveInDatabaseCopyWith<T, $Res> {
  __$$NotValidToSaveInDatabaseCopyWithImpl(_$NotValidToSaveInDatabase<T> _value,
      $Res Function(_$NotValidToSaveInDatabase<T>) _then)
      : super(_value, _then);
}

/// @nodoc

class _$NotValidToSaveInDatabase<T> implements NotValidToSaveInDatabase<T> {
  const _$NotValidToSaveInDatabase();

  @override
  String toString() {
    return 'ValueFailure<$T>.notValidToSaveInDatabase()';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$NotValidToSaveInDatabase<T>);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() notValidToSaveInDatabase,
    required TResult Function() emptyValue,
  }) {
    return notValidToSaveInDatabase();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? notValidToSaveInDatabase,
    TResult? Function()? emptyValue,
  }) {
    return notValidToSaveInDatabase?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? notValidToSaveInDatabase,
    TResult Function()? emptyValue,
    required TResult orElse(),
  }) {
    if (notValidToSaveInDatabase != null) {
      return notValidToSaveInDatabase();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(NotValidToSaveInDatabase<T> value)
        notValidToSaveInDatabase,
    required TResult Function(EmptyValue<T> value) emptyValue,
  }) {
    return notValidToSaveInDatabase(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(NotValidToSaveInDatabase<T> value)?
        notValidToSaveInDatabase,
    TResult? Function(EmptyValue<T> value)? emptyValue,
  }) {
    return notValidToSaveInDatabase?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(NotValidToSaveInDatabase<T> value)?
        notValidToSaveInDatabase,
    TResult Function(EmptyValue<T> value)? emptyValue,
    required TResult orElse(),
  }) {
    if (notValidToSaveInDatabase != null) {
      return notValidToSaveInDatabase(this);
    }
    return orElse();
  }
}

abstract class NotValidToSaveInDatabase<T> implements ValueFailure<T> {
  const factory NotValidToSaveInDatabase() = _$NotValidToSaveInDatabase<T>;
}

/// @nodoc
abstract class _$$EmptyValueCopyWith<T, $Res> {
  factory _$$EmptyValueCopyWith(
          _$EmptyValue<T> value, $Res Function(_$EmptyValue<T>) then) =
      __$$EmptyValueCopyWithImpl<T, $Res>;
}

/// @nodoc
class __$$EmptyValueCopyWithImpl<T, $Res>
    extends _$ValueFailureCopyWithImpl<T, $Res, _$EmptyValue<T>>
    implements _$$EmptyValueCopyWith<T, $Res> {
  __$$EmptyValueCopyWithImpl(
      _$EmptyValue<T> _value, $Res Function(_$EmptyValue<T>) _then)
      : super(_value, _then);
}

/// @nodoc

class _$EmptyValue<T> implements EmptyValue<T> {
  const _$EmptyValue();

  @override
  String toString() {
    return 'ValueFailure<$T>.emptyValue()';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is _$EmptyValue<T>);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() notValidToSaveInDatabase,
    required TResult Function() emptyValue,
  }) {
    return emptyValue();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? notValidToSaveInDatabase,
    TResult? Function()? emptyValue,
  }) {
    return emptyValue?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? notValidToSaveInDatabase,
    TResult Function()? emptyValue,
    required TResult orElse(),
  }) {
    if (emptyValue != null) {
      return emptyValue();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(NotValidToSaveInDatabase<T> value)
        notValidToSaveInDatabase,
    required TResult Function(EmptyValue<T> value) emptyValue,
  }) {
    return emptyValue(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(NotValidToSaveInDatabase<T> value)?
        notValidToSaveInDatabase,
    TResult? Function(EmptyValue<T> value)? emptyValue,
  }) {
    return emptyValue?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(NotValidToSaveInDatabase<T> value)?
        notValidToSaveInDatabase,
    TResult Function(EmptyValue<T> value)? emptyValue,
    required TResult orElse(),
  }) {
    if (emptyValue != null) {
      return emptyValue(this);
    }
    return orElse();
  }
}

abstract class EmptyValue<T> implements ValueFailure<T> {
  const factory EmptyValue() = _$EmptyValue<T>;
}
